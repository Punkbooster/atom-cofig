var defaultOptions = {
	/**
	 * String for one-level indentation
	 * @type {String}
	 */
	indent: '\t',

	/**
	 * Tag case: 'lower', 'upper' or '' (keep as-is)
	 * @type {String}
	 */
	tagCase: '',

	/**
	 * Attribute name case: 'lower', 'upper' or '' (keep as-is)
	 * @type {String}
	 */
	attributeCase: '',

	/**
	 * Attribute value quotes: 'single' or 'double'
	 * @type {String}
	 */
	attributeQuotes: 'double',

	/**
	 * Enable output formatting (indentation and line breaks)
	 * @type {Boolean}
	 */
	format: true,

	/**
	 * A list of tag names that should not get inner indentation
	 * @type {Set}
	 */
	formatSkip: ['html'],

	/**
	 * A list of tag names that should *always* get inner indentation.
	 * @type {Set}
	 */
	formatForce: ['body'],

	/**
	 * How many inline sibling elements should force line break for each tag.
	 * Set to 0 to output all inline elements without formatting.
	 * Set to 1 to output all inline elements with formatting (same as block-level).
	 * @type {Number}
	 */
	inlineBreak: 3,

	/**
	 * Produce compact notation of boolean attribues: attributes where name equals value.
	 * With this option enabled, output `<div contenteditable>` instead of
	 * `<div contenteditable="contenteditable">`
	 * @type {Boolean}
	 */
	compactBooleanAttributes: false,

	/**
	 * A set of boolean attributes
	 * @type {Set}
	 */
	booleanAttributes: ['contenteditable', 'seamless', 'async', 'autofocus',
		'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',
		'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',
		'required', 'reversed', 'selected', 'typemustmatch'],

	/**
	 * Style of self-closing tags:
	 * 'html'  – <br>
	 * 'xml'   – <br/>
	 * 'xhtml' – <br />
	 * @type {String}
	 */
	selfClosingStyle: 'html',

	/**
	 * A set of inline-level elements
	 * @type {Set}
	 */
	inlineElements: ['a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',
		'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',
		'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',
		's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',
		'textarea', 'tt', 'u', 'var']
};

/**
 * Creates output profile for given options (@see defaults)
 * @param {defaults} options
 */
class Profile {
    constructor(options) {
        this.options = Object.assign({}, defaultOptions, options);
        this.quoteChar = this.options.attributeQuotes === 'single' ? '\'' : '"';
    }

	/**
	 * Returns value of given option name
	 * @param {String} name
	 * @return {*}
	 */
	get(name) {
		return this.options[name];
	}

    /**
     * Quote given string according to profile
     * @param {String} str String to quote
     * @return {String}
     */
    quote(str) {
        return `${this.quoteChar}${str != null ? str : ''}${this.quoteChar}`;
    }

    /**
     * Output given tag name accoding to options
     * @param {String} name
     * @return {String}
     */
    name(name) {
        return strcase(name, this.options.tagCase);
    }

	/**
	 * Outputs attribute name accoding to current settings
	 * @param {String} Attribute name
	 * @return {String}
	 */
    attribute(attr) {
        return strcase(attr, this.options.attributeCase);
    }

    /**
     * Check if given attribute is boolean
     * @param {Attribute} attr
     * @return {Boolean}
     */
    isBooleanAttribute(attr) {
        return attr.options.boolean
			|| this.get('booleanAttributes').indexOf((attr.name || '').toLowerCase()) !== -1;
    }

	/**
	 * Returns a token for self-closing tag, depending on current options
	 * @return {String}
	 */
	selfClose() {
		switch (this.options.selfClosingStyle) {
			case 'xhtml': return ' /';
			case 'xml':   return '/';
			default:      return '';
		}
	}

	/**
	 * Returns indent for given level
	 * @param {Number} level Indentation level
	 * @return {String}
	 */
	indent(level) {
		level = level || 0;
		let output = '';
		while (level--) {
			output += this.options.indent;
		}

		return output;
	}

	/**
	 * Check if given tag name belongs to inline-level element
	 * @param {Node|String} node Parsed node or tag name
	 * @return {Boolean}
	 */
	isInline(node) {
        if (typeof node === 'string') {
            return this.get('inlineElements').indexOf(node.toLowerCase()) !== -1;
        }

        // inline node is a node either with inline-level name or text-only node
        return node.name != null ? this.isInline(node.name) : node.isTextOnly;
	}

	/**
	 * Outputs formatted field for given params
	 * @param {Number} index Field index
	 * @param {String} [placeholder] Field placeholder, can be empty
	 * @return {String}
	 */
	field(index, placeholder) {
		return this.options.field(index, placeholder);
	}
}

function strcase(string, type) {
    if (type) {
        string = type === 'upper' ? string.toUpperCase() : string.toLowerCase();
    }
    return string;
}

export default Profile;
