'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator = _interopRequireDefault(require('async-to-generator'));

var _log4js;

function _load_log4js() {
  return _log4js = require('log4js');
}

var _atom = require('atom');

var _nuclideAnalytics;

function _load_nuclideAnalytics() {
  return _nuclideAnalytics = require('../../nuclide-analytics');
}

var _nuclideRpc;

function _load_nuclideRpc() {
  return _nuclideRpc = require('../../nuclide-rpc');
}

var _debounce;

function _load_debounce() {
  return _debounce = _interopRequireDefault(require('nuclide-commons/debounce'));
}

var _nuclideUri;

function _load_nuclideUri() {
  return _nuclideUri = _interopRequireDefault(require('nuclide-commons/nuclideUri'));
}

var _string;

function _load_string() {
  return _string = require('nuclide-commons/string');
}

var _loadingNotification;

function _load_loadingNotification() {
  return _loadingNotification = _interopRequireDefault(require('../../commons-atom/loading-notification'));
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Diffing is O(lines^2), so don't bother for files with too many lines.
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 *
 * 
 * @format
 */

const DIFF_LINE_LIMIT = 5000;

// Matches the default in Atom 1.19.
const CHANGE_DEBOUNCE = 200;

class NuclideTextBuffer extends _atom.TextBuffer {

  // This is a counter that will be incremented after every successful save request.
  // We use this to accurately detect changes on disk - conflicts should not be reported
  // if any saves finished while fetching the updated contents.
  constructor(connection, params) {
    super(params);
    this._exists = true;
    this._connection = connection;
    this._saveID = 0;
    this._pendingSaveContents = null;
    this.setPath(params.filePath);
    const encoding = atom.config.get('core.fileEncoding');
    this.setEncoding(encoding);
  }

  // Atom 1.4.0+ serializes TextBuffers with the ID generated by `getId`. When
  // a buffer is deserialized, it is looked up in the buffer cache by this key.
  // The logic there is setup to create a new buffer when there is a cache miss.
  // However, when there is no key, it's not looked up in cache, but rather by
  // its path. This behavior ensures that when a connection is reestablished,
  // a buffer exists with that path. See https://github.com/atom/atom/pull/9968.

  // Handling pending saves is also tricky. It's possible we get the file change event
  // before the file finishes saving, which is fine.

  /* $FlowFixMe */
  getId() {
    return '';
  }

  setPath(filePath) {
    if (!this._connection) {
      // If this._connection is not set, then the superclass constructor is still executing.
      // NuclideTextBuffer's constructor will ensure setPath() is called once this.constructor
      // is set.
      return;
    }
    if (filePath === this.getPath()) {
      return;
    }
    if (filePath) {
      if (this.file != null) {
        this.file.setPath(this._connection.getUriOfRemotePath(filePath));
      } else {
        this.file = this.createFile(filePath);
        if (this.file !== null) {
          const file = this.file;
          file.setEncoding(this.getEncoding());
          this.subscribeToFile();
        }
      }
    } else {
      this.file = null;
    }
    this.emitter.emit('did-change-path', this.getPath());
  }

  createFile(filePath) {
    return this._connection.createFile(filePath);
  }

  saveAs(filePath) {
    var _this = this;

    return (0, _asyncToGenerator.default)(function* () {
      if (!filePath) {
        throw new Error("Can't save buffer with no file path");
      }

      let success;
      _this.emitter.emit('will-save', { path: filePath });
      _this.setPath(filePath);
      const toSaveContents = _this.getText();
      try {
        const file = _this.file;

        if (!file) {
          throw new Error('Cannot save an null file!');
        }

        _this._pendingSaveContents = toSaveContents;
        yield (0, (_loadingNotification || _load_loadingNotification()).default)(file.write(toSaveContents), `Saving \`${(_nuclideUri || _load_nuclideUri()).default.nuclideUriToDisplayString(filePath)}\`...`, 1000 /* delay */
        );
        _this.cachedDiskContents = toSaveContents;
        _this._saveID++;
        _this.conflict = false;
        _this.emitModifiedStatusChanged(false);
        _this.emitter.emit('did-save', { path: filePath });
        success = true;
      } catch (e) {
        // Timeouts occur quite frequently when the network is unstable.
        // Demote these to 'error' level.
        const logger = (0, (_log4js || _load_log4js()).getLogger)('nuclide-remote-connection');
        const logFunction = e instanceof (_nuclideRpc || _load_nuclideRpc()).RpcTimeoutError ? logger.error : logger.fatal;
        logFunction('Failed to save remote file.', e);
        let message = e.message;
        // This can happen if the user triggered the save while closing the file.
        // Unfortunately, we can't interrupt the user action, but we can at least reopen the buffer.
        if (_this.destroyed) {
          message += '<br><br>Opening a new tab with your unsaved changes.';
          // goToLocation does not support opening an untitled editor
          // eslint-disable-next-line nuclide-internal/atom-apis
          atom.workspace.open().then(function (editor) {
            return editor.setText(toSaveContents);
          });
        }
        atom.notifications.addError(`Failed to save remote file ${filePath}: ${message}`);
        success = false;
      }

      // Once the save is finished, cachedDiskContents is the source of truth.
      _this._pendingSaveContents = null;

      (0, (_nuclideAnalytics || _load_nuclideAnalytics()).track)('remoteprojects-text-buffer-save-as', {
        'remoteprojects-file-path': filePath,
        'remoteprojects-save-success': success.toString()
      });
    })();
  }

  updateCachedDiskContentsSync() {
    throw new Error("updateCachedDiskContentsSync isn't supported in NuclideTextBuffer");
  }

  updateCachedDiskContents(flushCache, callback) {
    var _this2 = this;

    return (0, _asyncToGenerator.default)(function* () {
      try {
        // Babel workaround: w/o the es2015-classes transform, async functions can't call `super`.
        // https://github.com/babel/babel/issues/3930
        yield _atom.TextBuffer.prototype.updateCachedDiskContents.call(_this2, flushCache, callback);
        _this2._exists = true;
      } catch (e) {
        _this2._exists = false;
        throw e;
      }
    })();
  }

  // Override of TextBuffer's implementation.
  // Atom tries to diff contents even for extremely large files, which can
  // easily cause the editor to lock.
  // TODO(hansonw): Remove after https://github.com/atom/text-buffer/issues/153 is resolved.
  setTextViaDiff(newText) {
    if (this.getLineCount() > DIFF_LINE_LIMIT || (0, (_string || _load_string()).countOccurrences)(newText, '\n') > DIFF_LINE_LIMIT) {
      this.setText(newText);
    } else {
      super.setTextViaDiff(newText);
    }
  }

  subscribeToFile() {
    var _this3 = this;

    if (this.fileSubscriptions) {
      this.fileSubscriptions.dispose();
    }
    const file = this.file;

    if (!file) {
      throw new Error('Cannot subscribe to no-file');
    }

    const fileSubscriptions = new _atom.CompositeDisposable();

    fileSubscriptions.add(file.onDidChange((0, (_debounce || _load_debounce()).default)((0, _asyncToGenerator.default)(function* () {
      // The buffer could have been destroyed during the debounce.
      if (_this3.destroyed) {
        return;
      }
      const isModified = _this3._isModified();
      _this3.emitModifiedStatusChanged(isModified);
      if (isModified) {
        _this3.conflict = true;
      }
      const previousContents = _this3.cachedDiskContents;
      const previousSaveID = _this3._saveID;
      yield _this3.updateCachedDiskContents();
      // The buffer could have been destroyed while waiting.
      if (_this3.destroyed) {
        return;
      }
      // If any save requests finished in the meantime, previousContents is not longer accurate.
      // The most recent save request should trigger another change event, so we'll check for
      // conflicts when that happens.
      // Also, if a save is currently pending, it's possible we get the change event before the
      // write promise comes back.
      // Otherwise, what we wrote and what we read should match exactly.
      if (_this3._saveID !== previousSaveID || previousContents === _this3.cachedDiskContents || _this3._pendingSaveContents === _this3.cachedDiskContents) {
        _this3.conflict = false;
        return;
      }
      if (_this3.conflict) {
        _this3.emitter.emit('did-conflict');
      } else {
        _this3.reload();
      }
    }), CHANGE_DEBOUNCE)));

    fileSubscriptions.add(file.onDidDelete(() => {
      this._exists = false;
      const modified = this.getText() !== this.cachedDiskContents;
      this.wasModifiedBeforeRemove = modified;
      if (modified) {
        this.updateCachedDiskContents();
      } else {
        this._maybeDestroy();
      }
    }));

    // TODO: Not supported by RemoteFile.
    // fileSubscriptions.add(file.onDidRename(() => {
    //   this.emitter.emit('did-change-path', this.getPath());
    // }));

    fileSubscriptions.add(file.onWillThrowWatchError(errorObject => {
      this.emitter.emit('will-throw-watch-error', errorObject);
    }));

    this.fileSubscriptions = fileSubscriptions;
  }

  _maybeDestroy() {
    if (this.shouldDestroyOnFileDelete == null || this.shouldDestroyOnFileDelete()) {
      this.destroy();
    } else {
      if (this.fileSubscriptions != null) {
        // Soft delete the file.
        this.fileSubscriptions.dispose();
      }
      this.conflict = false;
      this.cachedDiskContents = null;
      this.emitModifiedStatusChanged(!this.isEmpty());
    }
  }

  _isModified() {
    if (!this.loaded) {
      return false;
    }
    if (this.file) {
      if (this._exists) {
        return this.getText() !== this.cachedDiskContents;
      } else {
        return this.wasModifiedBeforeRemove ? !this.isEmpty() : false;
      }
    } else {
      return !this.isEmpty();
    }
  }
}
exports.default = NuclideTextBuffer;