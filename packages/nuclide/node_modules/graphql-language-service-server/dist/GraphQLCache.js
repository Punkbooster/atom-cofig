'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GraphQLCache = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getGraphQLCache = getGraphQLCache;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _graphql = require('graphql');

var _nullthrows = require('nullthrows');

var _nullthrows2 = _interopRequireDefault(_nullthrows);

var _kinds = require('graphql/language/kinds');

var _graphqlLanguageServiceConfig = require('graphql-language-service-config');

var _GraphQLWatchman = require('./GraphQLWatchman');

var _MessageProcessor = require('./MessageProcessor');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           *  Copyright (c) Facebook, Inc.
                                                                                                                                                           *  All rights reserved.
                                                                                                                                                           *
                                                                                                                                                           *  This source code is licensed under the license found in the
                                                                                                                                                           *  LICENSE file in the root directory of this source tree.
                                                                                                                                                           *
                                                                                                                                                           *  
                                                                                                                                                           */

// Maximum files to read when processing GraphQL files.
var MAX_READS = 200;

function getGraphQLCache(configDir) {
  var graphQLConfig, watchmanClient;
  return regeneratorRuntime.async(function getGraphQLCache$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap((0, _graphqlLanguageServiceConfig.getGraphQLConfig)(configDir));

        case 2:
          graphQLConfig = _context.sent;
          watchmanClient = new _GraphQLWatchman.GraphQLWatchman();

          watchmanClient.checkVersion();

          watchmanClient.watchProject(configDir);
          return _context.abrupt('return', new GraphQLCache(configDir, graphQLConfig, watchmanClient));

        case 7:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this);
}

var GraphQLCache = exports.GraphQLCache = function () {
  function GraphQLCache(configDir, graphQLConfig, watchmanClient) {
    _classCallCheck(this, GraphQLCache);

    _initialiseProps.call(this);

    this._configDir = configDir;
    this._graphQLConfig = graphQLConfig;
    this._watchmanClient = watchmanClient || new _GraphQLWatchman.GraphQLWatchman();
    this._graphQLFileListCache = new Map();
    this._schemaMap = new Map();
    this._fragmentDefinitionsCache = new Map();
  }

  /**
   * Subscribes to the file changes and update the cache accordingly.
   * @param `rootDir` the directory of config path
   */
  GraphQLCache.prototype._subscribeToFileChanges = function _subscribeToFileChanges(rootDir, includeDirs, excludeDirs) {
    var _this = this;

    this._watchmanClient.subscribe(this._configDir, function (result) {
      if (result.files && result.files.length > 0) {
        var _graphQLFileMap = _this._graphQLFileListCache.get(rootDir);
        if (!_graphQLFileMap) {
          return;
        }
        result.files.forEach(function _callee(_ref) {
          var name = _ref.name,
              exists = _ref.exists,
              size = _ref.size,
              mtime = _ref.mtime;
          var filePath, existingFile, fileAndContent;
          return regeneratorRuntime.async(function _callee$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!(!includeDirs.some(function (dir) {
                    return name.startsWith(dir);
                  }) || excludeDirs.some(function (dir) {
                    return name.startsWith(dir);
                  }))) {
                    _context2.next = 2;
                    break;
                  }

                  return _context2.abrupt('return');

                case 2:
                  filePath = _path2.default.join(result.root, result.subscription, name);

                  // In the event of watchman recrawl (is_fresh_instance),
                  // watchman subscription returns a full set of files within the
                  // watched directory. After pruning with input/excluded directories,
                  // the file could have been created/modified.
                  // Using the cached size/mtime information, only cache the file if
                  // the file doesn't exist or the file exists and one of or both
                  // size/mtime is different.

                  if (!(result.is_fresh_instance && exists)) {
                    _context2.next = 13;
                    break;
                  }

                  existingFile = _graphQLFileMap.get(filePath);
                  // Same size/mtime means the file stayed the same

                  if (!(existingFile && existingFile.size === size && existingFile.mtime === mtime)) {
                    _context2.next = 7;
                    break;
                  }

                  return _context2.abrupt('return');

                case 7:
                  _context2.next = 9;
                  return regeneratorRuntime.awrap(_this.promiseToReadGraphQLFile(filePath));

                case 9:
                  fileAndContent = _context2.sent;

                  _graphQLFileMap.set(filePath, _extends({}, fileAndContent, {
                    size: size,
                    mtime: mtime
                  }));
                  // Otherwise, create/update the cache with the updated file and
                  // content, or delete the cache if (!exists)
                  _context2.next = 21;
                  break;

                case 13:
                  if (!_graphQLFileMap) {
                    _context2.next = 20;
                    break;
                  }

                  _context2.t0 = _this._graphQLFileListCache;
                  _context2.t1 = rootDir;
                  _context2.next = 18;
                  return regeneratorRuntime.awrap(_this._updateGraphQLFileListCache(_graphQLFileMap, { size: size, mtime: mtime }, filePath, exists));

                case 18:
                  _context2.t2 = _context2.sent;

                  _context2.t0.set.call(_context2.t0, _context2.t1, _context2.t2);

                case 20:

                  _this._updateFragmentDefinitionCache(rootDir, filePath, exists);

                case 21:
                case 'end':
                  return _context2.stop();
              }
            }
          }, null, _this);
        });
      }
    });
  };

  GraphQLCache.prototype._updateGraphQLFileListCache = function _updateGraphQLFileListCache(graphQLFileMap, metrics, filePath, exists) {
    var fileAndContent, graphQLFileInfo, existingFile;
    return regeneratorRuntime.async(function _updateGraphQLFileListCache$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!exists) {
              _context3.next = 6;
              break;
            }

            _context3.next = 3;
            return regeneratorRuntime.awrap(this.promiseToReadGraphQLFile(filePath));

          case 3:
            _context3.t0 = _context3.sent;
            _context3.next = 7;
            break;

          case 6:
            _context3.t0 = null;

          case 7:
            fileAndContent = _context3.t0;
            graphQLFileInfo = _extends({}, fileAndContent, metrics);
            existingFile = graphQLFileMap.get(filePath);

            // 3 cases for the cache invalidation: create/modify/delete.
            // For create/modify, swap the existing entry if available;
            // otherwise, just push in the new entry created.
            // For delete, check `exists` and splice the file out.

            if (existingFile && !exists) {
              graphQLFileMap.delete(filePath);
            } else if (graphQLFileInfo) {
              graphQLFileMap.set(filePath, graphQLFileInfo);
            }

            return _context3.abrupt('return', graphQLFileMap);

          case 12:
          case 'end':
            return _context3.stop();
        }
      }
    }, null, this);
  };

  GraphQLCache.prototype.updateFragmentDefinition = function updateFragmentDefinition(rootDir, filePath, contents) {
    var cache, asts;
    return regeneratorRuntime.async(function updateFragmentDefinition$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            cache = this._fragmentDefinitionsCache.get(rootDir);
            asts = contents.map(function (_ref2) {
              var query = _ref2.query;

              try {
                return { ast: (0, _graphql.parse)(query), query: query };
              } catch (error) {
                return { ast: null, query: query };
              }
            });

            if (cache) {
              // first go through the fragment list to delete the ones from this file
              cache.forEach(function (value, key) {
                if (value.filePath === filePath) {
                  cache.delete(key);
                }
              });
              asts.forEach(function (_ref3) {
                var ast = _ref3.ast,
                    query = _ref3.query;

                if (!ast) {
                  return;
                }
                ast.definitions.forEach(function (definition) {
                  if (definition.kind === _kinds.FRAGMENT_DEFINITION) {
                    cache.set(definition.name.value, {
                      filePath: filePath,
                      content: query,
                      definition: definition
                    });
                  }
                });
              });
            }

          case 3:
          case 'end':
            return _context4.stop();
        }
      }
    }, null, this);
  };

  GraphQLCache.prototype._updateFragmentDefinitionCache = function _updateFragmentDefinitionCache(rootDir, filePath, exists) {
    var fileAndContent, cache;
    return regeneratorRuntime.async(function _updateFragmentDefinitionCache$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (!exists) {
              _context5.next = 6;
              break;
            }

            _context5.next = 3;
            return regeneratorRuntime.awrap(this.promiseToReadGraphQLFile(filePath));

          case 3:
            _context5.t0 = _context5.sent;
            _context5.next = 7;
            break;

          case 6:
            _context5.t0 = null;

          case 7:
            fileAndContent = _context5.t0;

            // In the case of fragment definitions, the cache could just map the
            // definition name to the parsed ast, whether or not it existed
            // previously.
            // For delete, remove the entry from the set.
            if (!exists) {
              cache = this._fragmentDefinitionsCache.get(rootDir);

              if (cache) {
                cache.delete(filePath);
              }
            } else if (fileAndContent && fileAndContent.queries) {
              this.updateFragmentDefinition(rootDir, filePath, fileAndContent.queries);
            }

          case 9:
          case 'end':
            return _context5.stop();
        }
      }
    }, null, this);
  };

  GraphQLCache.prototype._extendSchema = function _extendSchema(schema, schemaPath) {
    var graphQLFileMap = this._graphQLFileListCache.get(this._configDir);
    var typeExtensions = [];
    if (!graphQLFileMap) {
      return schema;
    }
    graphQLFileMap.forEach(function (_ref4) {
      var filePath = _ref4.filePath,
          asts = _ref4.asts;

      asts.forEach(function (ast) {
        if (filePath === schemaPath) {
          return;
        }
        ast.definitions.forEach(function (definition) {
          switch (definition.kind) {
            case _kinds.OBJECT_TYPE_DEFINITION:
            case _kinds.INTERFACE_TYPE_DEFINITION:
            case _kinds.ENUM_TYPE_DEFINITION:
            case _kinds.UNION_TYPE_DEFINITION:
            case _kinds.SCALAR_TYPE_DEFINITION:
            case _kinds.INPUT_OBJECT_TYPE_DEFINITION:
            case _kinds.TYPE_EXTENSION_DEFINITION:
            case _kinds.DIRECTIVE_DEFINITION:
              typeExtensions.push(definition);
              break;
          }
        });
      });
    });
    return (0, _graphql.extendSchema)(schema, {
      kind: _kinds.DOCUMENT,
      definitions: typeExtensions
    });
  };

  /**
  * Given a list of GraphQL file metadata, read all files collected from watchman
  * and create fragmentDefinitions and GraphQL files cache.
  */


  /**
  * Takes an array of GraphQL File information and batch-processes into a
  * map of fragmentDefinitions and GraphQL file cache.
  */


  /**
  * Returns a Promise to read a GraphQL file and return a GraphQL metadata
  * including a parsed AST.
  */


  return GraphQLCache;
}();

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.getGraphQLConfig = function () {
    return _this2._graphQLConfig;
  };

  this.getFragmentDependencies = function _callee2(query, fragmentDefinitions) {
    var parsedQuery;
    return regeneratorRuntime.async(function _callee2$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (fragmentDefinitions) {
              _context6.next = 2;
              break;
            }

            return _context6.abrupt('return', []);

          case 2:
            // If the query cannot be parsed, validations cannot happen yet.
            // Return an empty array.
            parsedQuery = void 0;
            _context6.prev = 3;

            parsedQuery = (0, _graphql.parse)(query);
            _context6.next = 10;
            break;

          case 7:
            _context6.prev = 7;
            _context6.t0 = _context6['catch'](3);
            return _context6.abrupt('return', []);

          case 10:
            return _context6.abrupt('return', _this2.getFragmentDependenciesForAST(parsedQuery, fragmentDefinitions));

          case 11:
          case 'end':
            return _context6.stop();
        }
      }
    }, null, _this2, [[3, 7]]);
  };

  this.getFragmentDependenciesForAST = function _callee3(parsedQuery, fragmentDefinitions) {
    var existingFrags, referencedFragNames, asts, referencedFragments;
    return regeneratorRuntime.async(function _callee3$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (fragmentDefinitions) {
              _context7.next = 2;
              break;
            }

            return _context7.abrupt('return', []);

          case 2:
            existingFrags = new Map();
            referencedFragNames = new Set();


            (0, _graphql.visit)(parsedQuery, {
              FragmentDefinition: function FragmentDefinition(node) {
                existingFrags.set(node.name.value, true);
              },
              FragmentSpread: function FragmentSpread(node) {
                if (!referencedFragNames.has(node.name.value)) {
                  referencedFragNames.add(node.name.value);
                }
              }
            });

            asts = new Set();

            referencedFragNames.forEach(function (name) {
              if (!existingFrags.has(name) && fragmentDefinitions.has(name)) {
                asts.add((0, _nullthrows2.default)(fragmentDefinitions.get(name)));
              }
            });

            referencedFragments = [];


            asts.forEach(function (ast) {
              (0, _graphql.visit)(ast.definition, {
                FragmentSpread: function FragmentSpread(node) {
                  if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {
                    asts.add((0, _nullthrows2.default)(fragmentDefinitions.get(node.name.value)));
                    referencedFragNames.add(node.name.value);
                  }
                }
              });
              if (!existingFrags.has(ast.definition.name.value)) {
                referencedFragments.push(ast);
              }
            });

            return _context7.abrupt('return', referencedFragments);

          case 10:
          case 'end':
            return _context7.stop();
        }
      }
    }, null, _this2);
  };

  this.getFragmentDefinitions = function _callee4(graphQLConfig, appName) {
    var rootDir, includeDirs, excludeDirs, filesFromInputDirs, list, _ref5, fragmentDefinitions, graphQLFileMap;

    return regeneratorRuntime.async(function _callee4$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            // This function may be called from other classes.
            // If then, check the cache first.
            rootDir = graphQLConfig.getRootDir();

            if (!_this2._fragmentDefinitionsCache.has(rootDir)) {
              _context8.next = 3;
              break;
            }

            return _context8.abrupt('return', _this2._fragmentDefinitionsCache.get(rootDir) || new Map());

          case 3:
            includeDirs = graphQLConfig.getIncludeDirs(appName);
            excludeDirs = graphQLConfig.getExcludeDirs(appName);
            _context8.next = 7;
            return regeneratorRuntime.awrap(_this2._watchmanClient.listFiles(rootDir, {
              path: includeDirs
            }));

          case 7:
            filesFromInputDirs = _context8.sent;
            list = filesFromInputDirs.map(function (fileInfo) {
              return {
                filePath: _path2.default.join(rootDir, fileInfo.name),
                size: fileInfo.size,
                mtime: fileInfo.mtime
                // Filter any files with path starting with ExcludeDirs
              };
            }).filter(function (fileInfo) {
              return excludeDirs.every(function (exclude) {
                return !fileInfo.filePath.startsWith(_path2.default.join(rootDir, exclude));
              });
            });
            _context8.next = 11;
            return regeneratorRuntime.awrap(_this2.readAllGraphQLFiles(list));

          case 11:
            _ref5 = _context8.sent;
            fragmentDefinitions = _ref5.fragmentDefinitions;
            graphQLFileMap = _ref5.graphQLFileMap;


            _this2._fragmentDefinitionsCache.set(rootDir, fragmentDefinitions);
            _this2._graphQLFileListCache.set(rootDir, graphQLFileMap);

            _this2._subscribeToFileChanges(rootDir, includeDirs, excludeDirs);

            return _context8.abrupt('return', fragmentDefinitions);

          case 18:
          case 'end':
            return _context8.stop();
        }
      }
    }, null, _this2);
  };

  this.getSchema = function _callee5(configSchemaPath, appName) {
    var schemaPath, _schema, schemaDSL, schemaFileExt, schema;

    return regeneratorRuntime.async(function _callee5$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            if (configSchemaPath) {
              _context9.next = 2;
              break;
            }

            return _context9.abrupt('return', null);

          case 2:
            schemaPath = _path2.default.join(_this2._configDir, configSchemaPath);

            if (!_this2._schemaMap.has(schemaPath)) {
              _context9.next = 6;
              break;
            }

            _schema = _this2._schemaMap.get(schemaPath);
            return _context9.abrupt('return', _schema ? _this2._extendSchema(_schema, schemaPath) : _schema);

          case 6:
            _context9.next = 8;
            return regeneratorRuntime.awrap(new Promise(function (resolve) {
              return _fs2.default.readFile(schemaPath, 'utf8', function (error, content) {
                if (error) {
                  throw new Error(error);
                }
                resolve(content + '\n' + _this2._graphQLConfig.getCustomDirectives(appName).join('\n'));
              });
            }));

          case 8:
            schemaDSL = _context9.sent;
            schemaFileExt = _path2.default.extname(schemaPath);
            schema = void 0;
            _context9.prev = 11;
            _context9.t0 = schemaFileExt;
            _context9.next = _context9.t0 === '.graphql' ? 15 : _context9.t0 === '.json' ? 17 : 19;
            break;

          case 15:
            schema = (0, _graphql.buildSchema)(schemaDSL);
            return _context9.abrupt('break', 20);

          case 17:
            schema = (0, _graphql.buildClientSchema)(JSON.parse(schemaDSL));
            return _context9.abrupt('break', 20);

          case 19:
            throw new Error('Unsupported schema file extention');

          case 20:
            _context9.next = 25;
            break;

          case 22:
            _context9.prev = 22;
            _context9.t1 = _context9['catch'](11);
            throw new Error(_context9.t1);

          case 25:

            if (_this2._graphQLFileListCache.has(_this2._configDir)) {
              schema = _this2._extendSchema(schema, schemaPath);
            }

            _this2._schemaMap.set(schemaPath, schema);
            return _context9.abrupt('return', schema);

          case 28:
          case 'end':
            return _context9.stop();
        }
      }
    }, null, _this2, [[11, 22]]);
  };

  this.readAllGraphQLFiles = function _callee6(list) {
    var queue, responses, chunk, promises;
    return regeneratorRuntime.async(function _callee6$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            queue = list.slice(); // copy

            responses = [];

          case 2:
            if (!queue.length) {
              _context10.next = 9;
              break;
            }

            chunk = queue.splice(0, MAX_READS);
            promises = chunk.map(function (fileInfo) {
              return _this2.promiseToReadGraphQLFile(fileInfo.filePath).catch(function (error) {
                /**
                * fs emits `EMFILE | ENFILE` error when there are too many
                * open files - this can cause some fragment files not to be
                * processed.  Solve this case by implementing a queue to save
                * files failed to be processed because of `EMFILE` error,
                * and await on Promises created with the next batch from the
                * queue.
                */
                if (error.code === 'EMFILE' || error.code === 'ENFILE') {
                  queue.push(fileInfo);
                }
              }).then(function (response) {
                return responses.push(_extends({}, response, {
                  mtime: fileInfo.mtime,
                  size: fileInfo.size
                }));
              });
            });
            _context10.next = 7;
            return regeneratorRuntime.awrap(Promise.all(promises));

          case 7:
            _context10.next = 2;
            break;

          case 9:
            return _context10.abrupt('return', _this2.processGraphQLFiles(responses));

          case 10:
          case 'end':
            return _context10.stop();
        }
      }
    }, null, _this2);
  };

  this.processGraphQLFiles = function (responses) {
    var fragmentDefinitions = new Map();
    var graphQLFileMap = new Map();

    responses.forEach(function (response) {
      var filePath = response.filePath,
          content = response.content,
          asts = response.asts,
          mtime = response.mtime,
          size = response.size;


      if (asts) {
        asts.forEach(function (ast) {
          ast.definitions.forEach(function (definition) {
            if (definition.kind === _kinds.FRAGMENT_DEFINITION) {
              fragmentDefinitions.set(definition.name.value, {
                filePath: filePath,
                content: content,
                definition: definition
              });
            }
          });
        });
      }

      // Relay the previous object whether or not ast exists.
      graphQLFileMap.set(filePath, {
        filePath: filePath,
        content: content,
        asts: asts,
        mtime: mtime,
        size: size
      });
    });

    return { fragmentDefinitions: fragmentDefinitions, graphQLFileMap: graphQLFileMap };
  };

  this.promiseToReadGraphQLFile = function (filePath) {
    return new Promise(function (resolve, reject) {
      return _fs2.default.readFile(filePath, 'utf8', function (error, content) {
        if (error) {
          reject(error);
          return;
        }

        var asts = [];
        var queries = [];
        if (content.trim().length !== 0) {
          try {
            queries = (0, _MessageProcessor.getQueryAndRange)(content, filePath);
            if (queries.length === 0) {
              // still resolve with an empty ast
              resolve({ filePath: filePath, content: content, asts: [], queries: [] });
              return;
            }

            queries.forEach(function (_ref6) {
              var query = _ref6.query;
              return asts.push((0, _graphql.parse)(query));
            });
          } catch (_) {
            // If query has syntax errors, go ahead and still resolve
            // the filePath and the content, but leave ast empty.
            resolve({ filePath: filePath, content: content, asts: [], queries: [] });
            return;
          }
        }
        resolve({ filePath: filePath, content: content, asts: asts, queries: queries });
      });
    });
  };
};